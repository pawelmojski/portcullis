# v1.4 - Recursive Groups & Enhanced Policies (January 2026) âœ… COMPLETED

## ðŸŽ¯ Major Features Delivered

### 1. Hierarchical User Groups
- **Recursive Hierarchy**: Groups can have parent groups (e.g., root â†’ admins â†’ users)
- **BFS Traversal**: Efficient cycle detection with breadth-first search
- **Automatic Inheritance**: Members inherit permissions from all parent groups
- **Web GUI**: Complete CRUD interface at `/user-groups`
- **Tree Visualization**: JavaScript-based hierarchy viewer with member counts
- **Member Management**: Add/remove users from groups with breadcrumbs navigation
- **Database**: `user_groups` table with `parent_group_id` foreign key

### 2. Access Control Priority System
- **Priority Logic**: Direct user policies override group policies completely
- **No Fallback**: When user has explicit policy, group inheritance is blocked
- **SSH Login Filtering**: Early validation prevents incorrect group fallback
- **Permanent Policies**: Fixed `end_time=NULL` handling for permanent access
- **Debug Logging**: Clear messages showing which policy type is used
- **Example**: User with "ideo" login policy won't use group's "p.mojski" policy

### 3. Port Forwarding Control
- **Policy-Level Permission**: `port_forwarding_allowed` moved from groups to policies
- **Granular Control**: Enable forwarding per user/group and per server/service
- **SSH Forwarding**: Supports -L (local), -R (remote), -D (dynamic SOCKS)
- **Web UI**: Checkbox in policy creation form with clear description
- **Database Migration**: Column moved from `user_groups` to `access_policies`

### 4. Enhanced Policy UI
- **Consistent Interface**: Grant type dropdown matches server type dropdown
- **User vs Group**: Dropdown selection instead of radio buttons
- **Default Duration**: 1 hour pre-filled (0 for permanent access)
- **Section Renaming**: "Scope" â†’ "Server" for clarity
- **Auto-Toggle**: Fields show/hide based on grant type selection

## ðŸ“ Files Created/Modified

**New Files**:
- `src/web/blueprints/user_groups.py` (271 lines) - CRUD for hierarchical groups
- `src/web/templates/user_groups/index.html` - List with tree visualization
- `src/web/templates/user_groups/view.html` - Group details with breadcrumbs
- `src/web/templates/user_groups/add.html` - Create group form
- `src/web/templates/user_groups/edit.html` - Edit group with cycle warning

**Modified Files**:
- `src/core/database.py` - Added UserGroup, UserGroupMember models, get_all_user_groups()
- `src/core/access_control_v2.py` - Priority logic with SSH login filtering
- `src/web/blueprints/policies.py` - Added user_group_id and port_forwarding_allowed
- `src/web/templates/policies/add.html` - Dropdown UI, port forwarding checkbox
- `src/web/templates/policies/index.html` - User/group icons in policy list

## ðŸ—„ï¸ Database Schema Changes

```sql
-- New Tables
CREATE TABLE user_groups (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    parent_group_id INTEGER REFERENCES user_groups(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT user_groups_no_self_reference CHECK (id != parent_group_id)
);

CREATE TABLE user_group_members (
    id SERIAL PRIMARY KEY,
    user_group_id INTEGER REFERENCES user_groups(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    added_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_group_id, user_id)
);

-- Modified Tables
ALTER TABLE server_groups ADD COLUMN parent_group_id INTEGER REFERENCES server_groups(id);
ALTER TABLE access_policies ADD COLUMN user_group_id INTEGER REFERENCES user_groups(id);
ALTER TABLE access_policies ALTER COLUMN user_id DROP NOT NULL;
ALTER TABLE access_policies ADD COLUMN port_forwarding_allowed BOOLEAN DEFAULT false NOT NULL;
```

## ðŸ” Algorithm: Recursive Group Resolution

```python
def get_all_user_groups(user_id, db):
    """Get all groups user belongs to (direct + inherited via parents)
    
    Uses BFS with cycle detection to traverse hierarchy:
    1. Start with direct group memberships
    2. For each group, add its parent (if exists)
    3. Track visited groups to prevent infinite loops
    4. Return set of all group IDs
    """
    visited = set()
    queue = []
    
    # Get direct memberships
    direct = db.query(UserGroupMember).filter(
        UserGroupMember.user_id == user_id
    ).all()
    
    for member in direct:
        queue.append(member.user_group_id)
    
    # BFS traversal
    while queue:
        group_id = queue.pop(0)
        
        if group_id in visited:
            continue  # Cycle detected, skip
        
        visited.add(group_id)
        
        # Get parent group
        group = db.query(UserGroup).filter(UserGroup.id == group_id).first()
        if group and group.parent_group_id:
            queue.append(group.parent_group_id)
    
    return list(visited)
```

## ðŸ“Š Testing Results

**Hierarchy Testing**:
- **3-level hierarchy**: root â†’ admins â†’ users âœ…
- **Cycle detection**: Prevented A â†’ B â†’ C â†’ A âœ…
- **Permission inheritance**: User in "users" gets "root" permissions âœ…
- **Web GUI**: Tree visualization showing hierarchy correctly âœ…

**Priority Logic Testing**:
- **Direct user policy**: Overrides group policy completely âœ…
- **SSH login filtering**: "ideo" allowed, "p.mojski" denied âœ…
- **Group fallback blocked**: No mixing of user+group policies âœ…
- **Permanent policies**: `end_time=NULL` handled correctly âœ…

**Port Forwarding**:
- **Policy checkbox**: Shows in add form, saves to database âœ…
- **User groups cleanup**: Removed checkbox from group management âœ…
- **Database migration**: Column moved successfully âœ…

## ðŸ› Critical Bugs Fixed

1. **Permanent Policy Not Matched**
   - Problem: Policies with `end_time=NULL` were filtered out
   - Root cause: `end_time >= now` fails for NULL values
   - Fix: Changed to `or_(end_time == None, end_time >= now)`
   - Result: Permanent policies work correctly

2. **Wrong Priority Logic**
   - Problem: User with direct policy could still use group logins
   - Root cause: SSH login filtering happened after policy selection
   - Fix: Moved login validation inside direct policy branch
   - Result: Explicit user grants fully override group inheritance

3. **Source IP Restriction**
   - Problem: Policy not matched due to wrong source IP
   - Root cause: User connected from IP #6, policy restricted to IP #5
   - Resolution: User connected from correct computer (Tailscale)
   - Lesson: Source IP filtering working as designed

## ðŸ’¡ Design Decisions

**Why Groups Hierarchy?**
- Simplifies permission management (grant to parent, all children inherit)
- Reflects real organizational structure (company â†’ department â†’ team)
- Reduces policy duplication (one policy for entire tree)

**Why Priority System?**
- Explicit grants should always override inherited permissions
- Prevents confusion when user has both direct and group policies
- Allows fine-grained exceptions (restrict one user in allowed group)

**Why Port Forwarding in Policies?**
- Port forwarding is a permission, not a group property
- Can enable/disable per-server basis (forward to dev, not prod)
- Consistent with other permissions (SSH logins, protocols)

**Why 1 Hour Default?**
- Short-lived grants encourage principle of least privilege
- Reduces security impact of forgotten/abandoned access
- 0 = permanent for intentional long-term access
